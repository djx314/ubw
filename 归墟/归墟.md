在这篇文章里, 我们新建一个类型系统模型, 用它来表示清水装入水桶的过程.

觉得代码多的可以直接跳到结果演示部分或者非程序员模式部分.

首先我们设计一个简单的 HList, 用来避免 implicit 操作, 这里可以看代码清单, 不作细表.

然后我们可以创建一个水桶现有的水和满水差距的模型:

trait Chaju {

  type Next <: Chaju
  def next: Next

  type M[I <: HList, Item] <: HList
  def tran[I <: HList, Item](m: I, item: Item): M[I, Item]

  type Add <: Chaju
  def add: Add

}

其中, Next 表示多装了一层水之后的新的差距, Add 表示增加桶的高度, Add 只在初始化的时候使用, tran 表示对水桶的内容的操作.

现在我们就可以创建一个满溢的模型了:

class Manyi extends Chaju {
  self =>

  override type Next = Manyi
  override def next: Manyi = self

  override type M[I <: HList, Item] = I
  override def tran[I <: HList, Item](m: I, item: Item): I = m

  override type Add = ChajuImpl[Manyi]
  override def add: ChajuImpl[Manyi] = new ChajuImpl(self)

}

它不会对水桶现有的水做其他操作, 而且它的 next 仍然是自身.

同样的, 我们可以很容易创建一个水桶还没满的加水模型:

class ChajuImpl[T <: Chaju](tail: T) extends Chaju {
  self =>

  override type Next = T
  override def next: T = tail

  override type M[I <: HList, Item] = I#Add[Item]
  override def tran[I <: HList, Item](m: I, item: Item): I#Add[Item] = m.add(item)

  override type Add = ChajuImpl[ChajuImpl[T]]
  override def add: ChajuImpl[ChajuImpl[T]] = new ChajuImpl(self)

}

最后我们设计一个水桶:

class HListM[I <: HList, B <: Chaju](val hlist: I, val tran: B) {
  type Add[Item] = HListM[B#M[I, Item], B#Next]
  def add[Item](item: Item): HListM[B#M[I, Item], B#Next] = new HListM(tran.tran(hlist, item), tran.next)
  override def toString: String                           = hlist.toString
}

当水桶的 tran 属性 next 到 Manyi 之后, 水桶实体的内容将不会有任何实际上的变化, 它将舍弃所有加进来的水.

现在我们来看看代码演示:

class ZeroHListM  extends HListM(HNil, Manyi.add.add.add.add)
object ZeroHListM extends ZeroHListM

val item = ZeroHListM.add(1).add("个").add("喵喵喵").add("满").add("自").add("溢").add("的").add("HList")
println(item.toString) //HNil, 1, 个, 喵喵喵, 满
val b: HNil#Add[Int]#Add[String]#Add[String]#Add[String] = item.hlist //检查类型

可以看到, 满字后面的文字将被忽略.

但它的真正价值不在于实体运算, 在于类型运算, 也就是说这是一段没有运行价值的代码:

//脱离实体的运算
type ZeroType = HListM[HNil, Manyi#Add#Add#Add#Add]
val ii: ZeroType#Add[Int]#Add[Date]#Add[String]#Add[String]#Add[String]#Add[String]#Add[String]#Add[String] = throw new Exception("abc")
val iiii: ZeroType#Add[Int]#Add[Date]#Add[String]#Add[String]#Add[String]                                   = ii
val iiiiii: ZeroType#Add[Int]#Add[Date]#Add[String]#Add[String]                                             = ii
val iiiiiiii: HNil#Add[Int]#Add[Date]#Add[String]#Add[String]                                               = ii.hlist

可以看到在第 4 项之后的所有 "水" 在类型级别被舍弃.

好了, 我们抛开代码, 进入非程序员模式:

所谓天地孕育万物, 其实这个满溢的模型也使用了盘古开天辟地的代码模型(详见 <重认知-天地初开>).

一桶没有满的水的构型是这样的:

...
...
...
溢出水流方向4
溢出水流方向3
溢出水流方向2
溢出水流方向1
期望装水的空位4
期望装水的空位3
期望装水的空位2
期望装水的空位1
水桶的水1
水桶的水2
水桶的水3
水桶的水4
大地1
大地2
大地3
...
...
...

其实就是把盘古开天辟地的模型的一般表示和逆向表示揉在一起.

流水满溢的水桶的构型是这样的:

...
...
...
溢出水流方向4
溢出水流方向3
溢出水流方向2
溢出水流方向1
水桶的水1
水桶的水2
水桶的水3
水桶的水4
大地1
大地2
大地3
...
...
...

但是自然规律和人的认知在这里有了冲突, 流水满溢之后向下流了, 所以满溢之后的构型应该是 期望的流水方向 流向了无限深的大地, 所以它的构型应该是这样的:

    ┌─────────────┐
    ↑             ↓
水桶的水1    溢出水流方向1
水桶的水2    溢出水流方向2
水桶的水3    溢出水流方向3
水桶的水4    溢出水流方向4
大地1        ...
大地2        ...
大地3        ...
...
...
...

至于日常所见的满溢的流水会流向泥土就超出了满溢这个概念的表示范围了, 在这里不作讨论.

现在我们把眼光放大一点, 女娲补天之后, 天地倾斜, 水向东流, 汇入大海, 但是大海的海水也有满溢之时, 那满溢的水流去哪里了? 在那时, 岸边观察的古人根据器皿逐渐由不满到满溢的构型想到了水的流向:

归墟