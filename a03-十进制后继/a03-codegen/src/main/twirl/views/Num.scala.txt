@(jinzhi: Int)

package shijinzhi

trait Jinzhi {
    type Take[J <: JinzhiItem] <: JinzhiItem
    type ItemAdd[J <: JinzhiItem, D] <: JinzhiItem
    type ReverseItem[T <: Jinzhi] <: Jinzhi
    type Reverse <: Jinzhi
    def take[J <: JinzhiItem](j: J): Take[J]
    def itemAdd[J <: JinzhiItem, D](j: J, d: D): ItemAdd[J, D]
    def reverseItem[T <: Jinzhi](t: T): ReverseItem[T]
    def reverse: Reverse
    type Up <: Jinzhi
    def up: Up
    @for(i <- 0 to (jinzhi - 1)) {
        type _@{i} <: Jinzhi
        def _@{i}: _@{i}
    }
}

class Point extends Jinzhi {
    self =>
    override type Take[J <: JinzhiItem] = J
    override type ItemAdd[J <: JinzhiItem, D] = J#Add[D]
    override def itemAdd[J <: JinzhiItem, D](j: J, d: D): J#Add[D] = j.add(d)
    override type ReverseItem[J <: Jinzhi] = J
    override type Reverse = Point
    override def take[J <: JinzhiItem](j: J): J = j
    override def reverseItem[T <: Jinzhi](t: T): T = t
    override def reverse: Point = self
    override type Up = Node_1[Point]
    override def up: Node_1[Point] = new Node_1(self)
    @for(ii <- 0 to (jinzhi - 1)) {
        override type _@{ii} = Node_@{ii}[Point]
        override def _@{ii}: Node_@{ii}[Point] = new Node_@{ii}(self)
    }
}

object Point {
    val value: Point = new Point
}

@for(i <- 0 to (jinzhi - 1)) {
    @if(i < (jinzhi - 1)) {
        class Node_@{i}[C <: Jinzhi](val c: C) extends Jinzhi {
            self =>
            override type Take[J <: JinzhiItem] = C#Take[J]#_@{i}
            override type ItemAdd[J <: JinzhiItem, D] = J#Replace@{i}[C#ItemAdd[J#_@{i}, D]]
            override def itemAdd[J <: JinzhiItem, D](j: J, d: D): J#Replace@{i}[C#ItemAdd[J#_@{i}, D]] = j.replace@{i}(c.itemAdd(j._@{i}, d))
            override type ReverseItem[J <: Jinzhi] = C#ReverseItem[J#_@{i}]
            override type Reverse = ReverseItem[Point]
            override def take[J <: JinzhiItem](j: J): C#Take[J]#_@{i} = c.take(j)._@{i}
            override def reverseItem[T <: Jinzhi](t: T): C#ReverseItem[T#_@{i}] = c.reverseItem(t._@{i})
            override def reverse: ReverseItem[Point] = reverseItem(new Point)
            override type Up = Node_@{i + 1}[C]
            override def up: Up = new Node_@{i + 1}(c)
            @for(ii <- 0 to (jinzhi - 1)) {
                override type _@{ii} = Node_@{ii}[Node_@{i}[C]]
                override def _@{ii}: Node_@{ii}[Node_@{i}[C]] = new Node_@{ii}(self)
            }
        }
    } else {
        class Node_@{i}[C <: Jinzhi](val c: C) extends Jinzhi {
            self =>
            override type Take[J <: JinzhiItem] = C#Take[J]#_@{i}
            override type ItemAdd[J <: JinzhiItem, D] = J#Replace@{i}[C#ItemAdd[J#_@{i}, D]]
            override def itemAdd[J <: JinzhiItem, D](j: J, d: D): J#Replace@{i}[C#ItemAdd[J#_@{i}, D]] = j.replace@{i}(c.itemAdd(j._@{i}, d))
            override type ReverseItem[J <: Jinzhi] = C#ReverseItem[J#_@{i}]
            override type Reverse = ReverseItem[Point]
            override def take[J <: JinzhiItem](j: J): C#Take[J]#_@{i} = c.take(j)._@{i}
            override def reverseItem[T <: Jinzhi](t: T): C#ReverseItem[T#_@{i}] = c.reverseItem(t._@{i})
            override def reverse: ReverseItem[Point] = reverseItem(new Point)
            override type Up = Node_0[C#Up]
            override def up: Up = new Node_0(c.up)
            @for(ii <- 0 to (jinzhi - 1)) {
                override type _@{ii} = Node_@{ii}[Node_@{i}[C]]
                override def _@{ii}: Node_@{ii}[Node_@{i}[C]] = new Node_@{ii}(self)
            }
        }
    }
}