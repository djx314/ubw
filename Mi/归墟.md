在这篇文章里, 我们新建一个类型系统模型, 用它来表示清水装入水桶的过程, 或者可以解释为江河汇入大海, 海水满溢流入归墟的过程.

我们来看看代码演示部分

val ZeroHListM = new 大海之初(HNil.add("原来海水1").add("原来海水2"), Manyi.add.add.add)

val item = ZeroHListM.add(1).add("个").add("满").add("溢").add("的").add("HList").add("例").add("子")
println(item.toString)    //满, 个, 1, 原来海水2, 原来海水1, HNil
println(item.归墟.toString) //子, 例, HList, 的, 溢, 归墟
val b: HNil#Add[String]#Add[String]#Add[Int]#Add[String]#Add[String] = item.海水 //检查类型

可以看到, 大海满水后面的文字将被忽略.

但它的真正价值不在于实体运算, 在于类型运算, 也就是说这是一段没有运行价值的代码:

//脱离实体的运算
type ZeroType = 大海之初[HNil, Manyi#Add#Add#Add]
val i1: ZeroType#Add[Int]#Add[Date]#Add[String]#Add[String]#Add[String]#Add[String]#Add[String]#Add[String] = throw new Exception("abc")
val i2: ZeroType#Add[Int]#Add[Date]#Add[String]#Add[String]#Add[String]                                     = i1
val i3: ZeroType#Add[Int]#Add[Date]#Add[String]                                                             = i1
val i4: HNil#Add[Int]#Add[Date]#Add[String]                                                                 = i1.海水

可以看到在第 3 项之后的所有 "水" 在类型级别被舍弃.

好了, 我们抛开代码, 进入非程序员模式:

所谓天地孕育万物, 其实这个满溢的模型也使用了盘古开天辟地的代码模型(详见 <重认知-天地初开>).

一桶没有满的水的构型是这样的:

...
...
...
溢出水流方向4
溢出水流方向3
溢出水流方向2
溢出水流方向1
期望装水的空位4
期望装水的空位3
期望装水的空位2
期望装水的空位1
大海的水1
大海的水2
大海的水3
大海的水4
大地1
大地2
大地3
...
...
...

其实就是把盘古开天辟地的模型的一般表示和逆向表示揉在一起.

但万水的归宿却不能是这样, 因为 溢出流水的方向 在类型系统方面有负担, 不能无限增加. 所以会有一个归墟. 我们可以看看归墟的代码:

trait Guixu {
  self =>
  type I
  type T = Guixu

  val head: I
  val tail: Guixu = self

  type AddWater[I] = Guixu
  def add[II](i: II): AddWater[I] = new Guixu {
    override type I = II
    override val head: II = i

    override type T = Guixu
    override val tail: Guixu = self

    override def toString = head.toString + ", " + self.toString
  }
}

object Guixu {

  val value: Guixu = new Guixu {
    self =>
    override type I = Guixu
    override val head: Guixu = self

    override def toString = "归墟"
  }

}

大家可以看到, 归墟 addWater 之后没有类型系统的负担, 仍然是自己类型本身. 但它的实现上是表现了水汇入了一个空间之内这个概念的, 在运行时对内存有负担.

而在古语描述中, 归墟是一个没有底的众水汇聚之处, 而归墟的 tail 正好是归墟自身体现了归墟是没有底的这个特性.

但是这段代码形到, 意不到. 准确地说, 这段代码更像是体现了舀水的过程, 在人观察到水满的时候把它舀去归墟那边.

在一个 70 毫升的大雨中漫步期间, 我想出了第二个实现(滑稽), 下面是效果代码:

type sc   = ShuichiZero#Add#Add#Add
type shui = HNil#Add[Int]#Add[String]#Add[Int]#Add[String]#Add[String]#Add[String]

type a1 = sc#Shendu[shui]
type b1 = a1#Con#M[shui]
val 溢水1: HNil#Add[Int]#Add[String]#Add[Int]#Add[String]#Add[String] = (throw new Exception("ii")): b1

type a2 = sc#Shendu[b1]
type b2 = a2#Con#M[b1]
val 溢水2: HNil#Add[Int]#Add[String]#Add[Int]#Add[String] = (throw new Exception("ii")): b2

type a3 = sc#Shendu[b2]
type b3 = a3#Con#M[b2]
val 溢水3: HNil#Add[Int]#Add[String]#Add[Int] = (throw new Exception("ii")): b3

type a4 = sc#Shendu[b3]
type b4 = a4#Con#M[b3]
val 溢水4: HNil#Add[Int]#Add[String]#Add[Int] = (throw new Exception("ii")): b4

type a5 = sc#Shendu[b4]
type b5 = a5#Con#M[b4]
val 溢水5: HNil#Add[Int]#Add[String]#Add[Int] = (throw new Exception("ii")): b5

可以看出, 水是先累积到超过最高的水线, 然后才流向归墟的(流向归墟的过程在 Runner.scala 中体现), 也就是雨水是先在路面累积然后才流去排水口的, 在水的高度低于满溢的高度之后, 水便不会再溢出, 除非再次重复加水和排水操作.